package Recursive_BackTracking;

import java.util.List;

/**
 * Write a recursive method maxSum that accepts a list of integers L and an integer 
 * limit n as its parameters and uses backtracking to find the maximum sum that can 
 * be generated by adding elements of L that does not exceed n. For example, if you are given the list of integers [7, 30, 8, 22, 6, 1, 14] and the limit of 19, 
 * the maximum sum that can be generated that does not exceed is 16, achieved by adding 7, 8, and 1. If the list L is empty, 
 * or if the limit is not a positive integer, or all of L's values exceed the limit, return 0. 
 * Each index's element in the list can be added to the sum only once, but the same number
 *  value might occur more than once in a list, in which case each occurrence might be 
 *  added to the sum. For example, if the list is [6, 2, 1] you may use up to one 6 in the sum, but if the list is [6, 2, 6, 1] you may use up to two sixes. 
 * @author victo
 *
 */
public class MaxSum 
{
//kadane algorithm is better at solving this problem.
//Because we need to recurse while also looking for a max
//so wee need to pass down the partial sum and compare the 
//sum returned from each recursion.

//speical case: return 0 if there is not an option.

public static int maxSum(List<Integer> list, int limit )
{
	 return maxSumHelper(limit, 0, 0, list);
}

private static int maxSumHelper(int limit, int partialsum, int index, List<Integer> array)
{
    //base case;index is invalid
    if(index == array.size())return partialsum;
    int subsum2 = maxSumHelper(limit, partialsum,index+1,array);
    if(partialsum+array.get(index)<=limit)
    subsum2 =Math.max(subsum2,maxSumHelper(limit, partialsum+array.get(index),index+1,array));
    return subsum2;
}

}
